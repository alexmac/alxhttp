/* eslint-disable @typescript-eslint/no-explicit-any */
/*
AUTOGENERATED: do not edit by hand, your changes will be overwritten 
*/

import { useMutation, UseMutationResult, useQuery, useQueryClient, UseQueryResult } from '@tanstack/react-query'
function assertVal<T>(val: T): asserts val is NonNullable<T> {
  if (val === undefined || val === null) {
    throw new Error(`Expected 'val' to be defined, but received ${val}`)
  }
}

export function assertVals<T>(arr: (T | null | undefined)[]): asserts arr is NonNullable<T>[] {
  arr.forEach((val, index) => {
    if (val === undefined || val === null) {
      throw new Error(`Expected element at index ${index} to be defined, but received ${val}`)
    }
  })
}

function unreachable(): never {
  throw new Error(`unreachable code reached`)
}

type QueryKey = (string | number | null | undefined)[]

enum ErrorCode {
  PydanticValidationError = 'PydanticValidationError',
  RequestError = 'RequestError',
}

/**
 * The union of all error types that the request could throw.
 *
 * url: /api/orgs
 *
 */
type ResponseErrors = ErrorModel | ErrorModel | PydanticValidationError

/**
 * When all else fails this error is thrown
 *
 */
const RequestError = { error: ErrorCode.RequestError, status_code: -1, request_id: null }

export type MatchInfo = { org_id: string }

export type OrgData = { org_name: string }

export type Org = { org_id: string; org_name: string; created_at: Date; updated_at: Date }

export type ErrorModel = { error: string; status_code: number; request_id: null | string }

export type PydanticValidationError = { error: ErrorCode.PydanticValidationError; status_code: number; request_id: null | string; errors: [PydanticErrorDetails] }

export type PydanticErrorDetails = { type: string; loc: [number | string]; msg: string; input: string; ctx: Record<string, string> | null }

type ArgType = MatchInfo & OrgData

type HookArgs = { org_id: null | string | undefined; org_name: null | string | undefined }

function getOrgFromWire(root: any): Org {
  return { org_id: root.org_id, org_name: root.org_name, created_at: new Date(root.created_at * 1000), updated_at: new Date(root.updated_at * 1000) }
}

function getErrorModelFromWire(root: any): ErrorModel {
  return { error: root.error, status_code: root.status_code, request_id: root.request_id }
}

function getPydanticValidationErrorFromWire(root: any): PydanticValidationError {
  return {
    error: root.error,
    status_code: root.status_code,
    request_id: root.request_id,
    errors: root.errors.map((v1: PydanticErrorDetails) => {
      return getPydanticErrorDetailsFromWire(v1)
    }),
  }
}

function getPydanticErrorDetailsFromWire(root: any): PydanticErrorDetails {
  return {
    type: root.type,
    loc: root.loc,
    msg: root.msg,
    input: root.input,
    ctx:
      root.ctx === null
        ? null
        : Object.fromEntries(
            Object.entries(root.ctx as Record<string, string>).map(([k2, v2]) => {
              return [k2, v2]
            }),
          ),
  }
}

function convertOrgDataToWire(root: any): OrgData {
  return { org_name: root.org_name }
}

/**
 * The main fetch wrapper that handles serialization/deserialization
 *
 * url: /api/orgs
 *
 * @param {string} org_name
 * @param {string} org_id
 * @returns {Org}
 *
 */
export async function createOrg(args: ArgType, base_url: string = 'http://127.0.0.1:8081/', timeout: number = 2000, ...rest: any[]): Promise<Org> {
  const { org_id, org_name } = args

  const url = `${base_url}api/orgs`
  const postBody = convertOrgDataToWire(args)
  const response = await fetch(url, { method: 'POST', body: JSON.stringify(postBody), headers: { 'content-type': 'application/json' } })

  if (response.status == 200) {
    return getOrgFromWire(await response.json())
  }

  const data = await response.json()

  if (data.error) {
    switch (data.error) {
      case ErrorCode.PydanticValidationError: {
        throw getPydanticValidationErrorFromWire(data)
      }
      default: {
        throw getErrorModelFromWire(data)
      }
    }
  }

  throw RequestError
}

/**
 * A hook that wraps the fetch call using a react-query mutation
 *
 * args are all nullable so this can be chained with the output of a previous hook easily.
 *
 * url: /api/orgs
 *
 * @param {string} org_name
 * @param {string} org_id
 * @return {Org} return
 *
 */
export function useCreateOrgMutation(args: HookArgs, invalidateQueryKey: QueryKey): UseMutationResult<Org, ResponseErrors, void, unknown> {
  const { org_id, org_name } = args

  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: async () => {
      assertVal(org_id)
      assertVal(org_name)
      assertVals(invalidateQueryKey)
      return await createOrg({ org_id, org_name })
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: invalidateQueryKey })
    },
  })
}

/**
 * A hook that wraps the fetch call using react-query.
 *
 * args are all nullable so this can be chained with the output of a previous hook easily.
 *
 * url: /api/orgs
 *
 * @param {string} org_name
 * @param {string} org_id
 * @returns {Org}
 *
 */
export function useCreateOrg(args: HookArgs): UseQueryResult<Org, ResponseErrors> {
  const { org_id, org_name } = args

  return useQuery({
    queryKey: ['useCreateOrg', org_id, org_name],
    staleTime: 5 * 1000,
    queryFn: async () => {
      assertVal(org_id)
      assertVal(org_name)
      return await createOrg({ org_id, org_name })
    },
    enabled: true && !!org_id && !!org_name,
  })
}
