/* eslint-disable @typescript-eslint/no-explicit-any */
/*
AUTOGENERATED: do not edit by hand, your changes will be overwritten 
*/

import { useMutation, UseMutationResult, useQueryClient } from '@tanstack/react-query'
function assertVal<T>(val: T): asserts val is NonNullable<T> {
  if (val === undefined || val === null) {
    throw new Error(`Expected 'val' to be defined, but received ${val}`)
  }
}

export function assertVals<T>(arr: (T | null | undefined)[]): asserts arr is NonNullable<T>[] {
  arr.forEach((val, index) => {
    if (val === undefined || val === null) {
      throw new Error(`Expected element at index ${index} to be defined, but received ${val}`)
    }
  })
}

function unreachable(): never {
  throw new Error(`unreachable code reached`)
}

type QueryKey = (string | number | null | undefined)[]

enum ErrorCode {
  PydanticValidationError = 'PydanticValidationError',
  RequestError = 'RequestError',
}

/**
 * The union of all error types that the request could throw.
 *
 * url: /api/orgs/{org_id}
 *
 */
type ResponseErrors = ErrorModel | ErrorModel | PydanticValidationError

/**
 * When all else fails this error is thrown
 *
 */
const RequestError = { error: ErrorCode.RequestError, status_code: -1, request_id: null }

export type MatchInfo = { org_id: string }

export type Empty = Record<string, unknown>

export type ErrorModel = { error: string; status_code: number; request_id: null | string }

export type PydanticValidationError = { error: ErrorCode.PydanticValidationError; status_code: number; request_id: null | string; errors: [PydanticErrorDetails] }

export type PydanticErrorDetails = { type: string; loc: [number | string]; msg: string; input: string; ctx: Record<string, string> | null }

type ArgType = MatchInfo & Empty

type HookArgs = { org_id: null | string | undefined }

function getEmptyFromWire(root: any): Empty {
  return {}
}

function getErrorModelFromWire(root: any): ErrorModel {
  return { error: root.error, status_code: root.status_code, request_id: root.request_id }
}

function getPydanticValidationErrorFromWire(root: any): PydanticValidationError {
  return {
    error: root.error,
    status_code: root.status_code,
    request_id: root.request_id,
    errors: root.errors.map((v1: PydanticErrorDetails) => {
      return getPydanticErrorDetailsFromWire(v1)
    }),
  }
}

function getPydanticErrorDetailsFromWire(root: any): PydanticErrorDetails {
  return {
    type: root.type,
    loc: root.loc,
    msg: root.msg,
    input: root.input,
    ctx:
      root.ctx === null
        ? null
        : Object.fromEntries(
            Object.entries(root.ctx as Record<string, string>).map(([k2, v2]) => {
              return [k2, v2]
            }),
          ),
  }
}

function convertEmptyToWire(root: any): Empty {
  return {}
}

/**
 * The main fetch wrapper that handles serialization/deserialization
 *
 * url: /api/orgs/{org_id}
 *
 * @param {string} org_id
 * @returns {Empty}
 *
 */
export async function deleteOrg(args: ArgType, base_url: string = 'http://127.0.0.1:8081/', timeout: number = 2000, ...rest: any[]): Promise<Empty> {
  const { org_id } = args

  const url = `${base_url}api/orgs/${org_id}`
  const response = await fetch(url, { method: 'DELETE' })

  if (response.status == 200) {
    return getEmptyFromWire(await response.json())
  }

  const data = await response.json()

  if (data.error) {
    switch (data.error) {
      case ErrorCode.PydanticValidationError: {
        throw getPydanticValidationErrorFromWire(data)
      }
      default: {
        throw getErrorModelFromWire(data)
      }
    }
  }

  throw RequestError
}

/**
 * A hook that wraps the fetch call using a react-query mutation
 *
 * args are all nullable so this can be chained with the output of a previous hook easily.
 *
 * url: /api/orgs/{org_id}
 *
 * @param {string} org_id
 * @return {Empty} return
 *
 */
export function useDeleteOrgMutation(args: HookArgs, invalidateQueryKey: QueryKey): UseMutationResult<Empty, ResponseErrors, void, unknown> {
  const { org_id } = args

  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: async () => {
      assertVal(org_id)
      assertVals(invalidateQueryKey)
      return await deleteOrg({ org_id })
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: invalidateQueryKey })
    },
  })
}
